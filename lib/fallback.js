// Generated by LiveScript 1.6.0
var bin, bufferFrom, out$ = typeof exports != 'undefined' && exports || this;
const path = require('path');
const child_process = require('child_process');
const split = require('split');
function exe(newBin){
  var old;
  newBin == null && (newBin = 'roots.exe');
  old = bin;
  bin = path.resolve(__dirname, newBin);
  return old;
} exe();
out$.exe = exe;
out$.sync = sync;
function sync(args){
  var queue, index;
  return {
    run: run,
    next: next,
    done: done
  };
  function next(){
    if (!queue) {
      queue = [];
      index = 0;
      run(function(it){
        if (it) {
          queue.push(it);
        }
      });
    }
    if (index < queue.length) {
      return queue[index++];
    }
    queue = [];
  }
  function done(){
    queue = [];
  }
  function run(callback){
    splitter(callback).on('end', function(){
      callback();
    }).end(child_process.execFileSync(bin, args));
  }
}
out$.async = async;
function async(args){
  var queue, requests, finished;
  return {
    run: run,
    next: next,
    done: done
  };
  function next(){
    if (!queue) {
      queue = [];
      requests = [];
      run(enqueue);
    }
    return queue.length
      ? Promise.resolve(queue.shift())
      : finished
        ? Promise.resolve()
        : new Promise(function(it){
          requests.push(it);
        });
  }
  function enqueue(it){
    if (finished) {
      return;
    }
    if (!it) {
      suspend();
    } else if (requests.length) {
      requests.shift()(it);
    } else {
      queue.push(it);
    }
  }
  function done(){
    queue = [];
    suspend();
  }
  function suspend(){
    var i$, ref$, len$, resolver;
    finished = true;
    for (i$ = 0, len$ = (ref$ = requests).length; i$ < len$; ++i$) {
      resolver = ref$[i$];
      resolver();
    }
  }
  function run(callback){
    var execRun = child_process.execFile(bin, args, { maxBuffer: 1024 * 1024 * 100 }, function(err){
      if (err) {
        console.error(err);
      }
    });
    
    execRun.stdout.pipe(splitter(callback)).on('end', function(){
      callback();
    });

    execRun.stdout.on('error', function (err) { 
      callback(err); 
    });
  }
}
function splitter(callback){
  return split(function(line){
    if (line.length) {
      callback(bufferFrom(line, 'hex'));
    }
  });
}
bufferFrom = Buffer.from || function(data, encoding){
  return new Buffer(data, encoding);
};